<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/12/26/hello-world/"/>
      <url>/2024/12/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>上下文无关文法</title>
      <link href="//post/context-has-nothing-to-do-with-z2unujt.html"/>
      <url>//post/context-has-nothing-to-do-with-z2unujt.html</url>
      
        <content type="html"><![CDATA[<p>第一次学编译原理的时候就听到了这个名词，然后就稀里糊涂的开始学词法分析、语法分析、first集、follow集，然后就是各种算法，但是最近回过头来重新学编译原理，发现自己连上下文无关文法是什么都不是很清楚。</p><p>所以这篇博客主要是简单的说明上下文无关文法是什么，他的分类准则是什么，除了这个什么别的文法，他们分别有什么特点。这边不会形式化的证明，但是会指出他们的特点，限制，以及应用场景。</p><h2 id="历史以及分类标准"><a href="#历史以及分类标准" class="headerlink" title="历史以及分类标准"></a>历史以及分类标准</h2><p>历史早期，主要是语言学的发展，语言学家发现语言中存在一些基本的组织规则，但缺乏形式化的描述方法。</p><p>上世纪50年代，诺姆·乔姆斯基(Noam Chomsky)在研究自然语言时定义了文法的层级，分别是:</p><ol><li><p>0型文法，一种无限制文法</p><ol><li>定义形式：α → β 其中 α 和 β 可以是任意的终结符和非终结符的组合字符串</li><li>一般只用在学术研究中</li></ol></li><li><p>1型文法，上下文有关文法。</p><ol><li>定义形式：<code>αAβ → αγβ </code>​其中 A 是非终结符，α、β 是上下文，γ 是非空字符串</li><li>简单来说就是产生式需要依赖上下文，比如对于英语中的系动词，am is are 他们的选择的跟上下文有关，这个文法可以用来辅助检测蛋白质结构。但是对于程序员来说不太需要关心这个事情。</li></ol></li><li><p>2型文法，上下文无关文法</p><ol><li>定义形式：<code>A → γ</code>​，其中 A 是非终结符，γ 是终结符和非终结符的任意组合</li><li>上下文无关的意思是，我们不需要关心上下文，我们可以在任何地方应用我们的产生式，将他进行转换。 我们编程语言中的语法分析就是上下文无法文法，可以判断我们写的代码是否符合语法规范。</li></ol></li><li><p>3型文法，正则文法</p><ol><li><p>定义形式： </p><ol><li>右线性：A → aB 或 A → a</li><li>左线性：A → Ba 或 A → a</li><li>其中 A、B 是非终结符，a 是终结符</li></ol></li><li><p>我们平时使用的正则表达式就是正则文法，但是他有很多限制，正如他的文法显示的，他必须在最左或者最右推导出一个终结符，这就导致他没有办法处理嵌套的场景。因为我们无法使用非终结符来保存嵌套状态</p></li></ol></li></ol><p>以上就是基本的分类，主要简单介绍什么是上下文无关文法。</p><p>‍</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>链接器如何处理静态库</title>
      <link href="//post/how-to-deal-with-the-static-library-1hrjwo.html"/>
      <url>//post/how-to-deal-with-the-static-library-1hrjwo.html</url>
      
        <content type="html"><![CDATA[<p>在软件开发中，链接是将各个编译单元组合成最终的可执行文件或库的关键步骤。对于使用 GNU 工具链（例如 GCC、G++）的开发者来说，理解链接器 <code>ld</code>​ 的工作原理至关重要。本文将深入探讨 GNU 链接器的工作机制，特别是关于链接顺序的细节，并提供一些实用技巧。</p><h2 id="链接的基础知识"><a href="#链接的基础知识" class="headerlink" title="链接的基础知识"></a>链接的基础知识</h2><p>GNU 链接器 <code>ld</code>​ 的基本工作单位是<strong>目标文件 (Object File)</strong> ，即 <code>.o</code>​ 文件，它们是源代码经过编译但尚未链接的中间产物。链接器主要关注目标文件中的两种符号：</p><ul><li><strong>导出符号 (Exported Symbols / Output Symbols)</strong> ：定义在目标文件内部，可以被其他目标文件使用的符号，例如函数或全局变量。</li><li><strong>未定义符号 (Undefined Symbols)</strong> ：目标文件中引用了但没有定义的符号，需要在链接阶段找到其定义。</li></ul><p>链接器的核心任务是解析所有目标文件的未定义符号，将它们与其它目标文件中的导出符号匹配起来，最终生成可执行文件或库。</p><p><strong>重要原则：</strong>​<code>ld</code>​ 要么链接整个目标文件，要么完全不链接。即使一个目标文件中只有少数符号被使用，整个目标文件的内容也会被链接到最终目标中。这也是为什么一些简单的 “Hello, World” 程序体积却很大的原因之一（因为它们链接了一些标准库，即使只用到了其中一小部分功能）。</p><h3 id="查看符号"><a href="#查看符号" class="headerlink" title="查看符号"></a>查看符号</h3><p>我们可以使用 <code>nm</code>​ 工具来查看目标文件和库中的符号信息。</p><ul><li><p>查看目标文件中的<strong>未定义符号</strong>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nm <span class="token parameter variable">-u</span> <span class="token operator">&lt;</span>object_file.o<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：<code>nm -u main.o</code>​</p></li><li><p>查看目标文件或库中的<strong>所有符号</strong>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nm <span class="token operator">&lt;</span>object_file.o or library.a<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：<code>nm b.o</code>​或者：<code>nm libb.a</code>​</p></li></ul><p>符号类型说明：</p><ul><li>​<code>U</code>​：表示未定义的符号。</li><li>​<code>T</code>​：表示代码段中的定义的符号。</li><li>​<code>D</code>​：表示已初始化的数据段中的定义的符号。</li><li>​<code>B</code>​：表示未初始化的数据段中的定义的符号。</li><li>​<code>C</code>​：表示COMMON 符号，通常是未初始化的全局变量。</li><li>​<code>W</code>​：表示弱符号。</li><li>​<code>...</code>​：更多符号类型请参考 <code>man nm</code>​。</li></ul><h2 id="目标文件链接：简单的算法"><a href="#目标文件链接：简单的算法" class="headerlink" title="目标文件链接：简单的算法"></a>目标文件链接：简单的算法</h2><p>当只涉及目标文件链接时，<code>ld</code>​ 使用一个简单的算法：</p><ol><li><p>维护两个列表：</p><ul><li><strong>已知符号列表 (Defined Symbols List)</strong> ：记录已解析的符号及其定义所在的目标文件。</li><li><strong>未知符号列表 (Undefined Symbols List)</strong> ：记录尚未找到定义的符号。</li></ul></li><li><p>依次处理每个目标文件：</p><ul><li>将目标文件中的所有导出符号加入<strong>已知符号列表</strong>。如果遇到符号冲突（多重定义），则报错。</li><li>用目标文件的导出符号解析<strong>未知符号列表</strong>中的符号，并将已解析的符号从<strong>未知符号列表</strong>中移除。</li><li>将目标文件中剩余的未定义符号加入<strong>未知符号列表</strong>。</li></ul></li><li><p>处理完所有目标文件后，如果<strong>未知符号列表</strong>非空，则报告 “undefined reference” 错误。</p></li></ol><p>在仅链接目标文件的情况下，链接顺序<strong>不影响</strong>最终结果。</p><h2 id="静态库链接：顺序的重要性"><a href="#静态库链接：顺序的重要性" class="headerlink" title="静态库链接：顺序的重要性"></a>静态库链接：顺序的重要性</h2><p>静态库（<code>.a</code>​ 文件）本质上是一组目标文件的集合。链接静态库时，<code>ld</code>​ 的行为略有不同，<strong>链接顺序变得至关重要</strong>。</p><ol><li>​<code>ld</code>​ 依次检查静态库中的每个目标文件。</li><li>如果一个目标文件的导出符号可以解决<strong>未知符号列表</strong>中的任何符号，则将该目标文件加入链接，更新<strong>已知符号列表</strong>和<strong>未知符号列表</strong>（参考上一节的步骤）。</li><li>如果一个目标文件无法解决<strong>未知符号列表</strong>中的任何符号，则<strong>跳过</strong>该目标文件。<strong>在没有特定选项的情况下，</strong>​<strong>​<code>ld</code>​</strong>​ <strong>后续不会重新考虑被跳过的目标文件</strong>。</li><li>如果步骤 2 中加入的目标文件引入了新的未定义符号，则 <code>ld</code>​ 会<strong>重新扫描</strong> <em>同一个</em> 静态库，尝试解析新引入的未定义符号。此过程重复进行，直到没有新的未定义符号，或者本轮扫描无法解析出任何新的未定义符号。</li></ol><p>**注意：**上述规则意味着同一个静态库内的目标文件链接顺序无关紧要。但是，不同静态库之间的链接顺序非常重要。</p><p><strong>示例：</strong></p><p>假设有三个源文件：</p><p>​<code>bar.cpp</code>​:</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;void bar() {    std::cout &lt;&lt; "bar()" &lt;&lt; std::endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​<code>foo.cpp</code>​:</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;void bar();void foo() {    std::cout &lt;&lt; "foo()" &lt;&lt; std::endl;    bar();}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​<code>main.cpp</code>​:</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;void foo();int main() {    std::cout &lt;&lt; "main()" &lt;&lt; std::endl;    foo();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果将 <code>foo.cpp</code>​ 和 <code>bar.cpp</code>​ 分别编译成静态库 <code>libfoo.a</code>​ 和 <code>libbar.a</code>​，则以下链接命令：</p><ul><li>​<code>g++ -o app.exe main.o libfoo.a libbar.a</code>​：<strong>成功</strong></li><li>​<code>g++ -o app.exe libfoo.a libbar.a main.o</code>​：<strong>失败</strong>，提示 <code>undefined reference to 'foo'</code>​</li><li>​<code>g++ -o app.exe main.o libbar.a libfoo.a</code>​：<strong>失败</strong>，提示 <code>undefined reference to 'bar'</code>​</li></ul><p><strong>解释：</strong></p><ul><li>第一个命令成功是因为 <code>main.o</code>​ 的未定义符号 <code>foo</code>​ 可以由 <code>libfoo.a</code>​ 解决，<code>libfoo.a</code>​ 的未定义符号<code>bar</code>​ 可以由<code>libbar.a</code>​ 解决。</li><li>第二个命令失败，因为 <code>ld</code>​ 先处理 <code>libfoo.a</code>​ 和 <code>libbar.a</code>​，当时 <code>main.o</code>​ 未处理，<code>foo</code>​ 还不在未知符号列表中，所以 <code>libfoo.a</code>​ 被跳过。然后处理<code>main.o</code>​ 时 <code>foo</code>​ 成为未定义符号，而 <code>libfoo.a</code>​ 已经被跳过，<code>foo</code>​ 无法解析。</li><li>第三个命令失败，因为 <code>main.o</code>​ 需要 <code>foo</code>​，<code>libbar.a</code>​ 无法提供，所以被跳过。<code>libfoo.a</code>​ 提供了 <code>foo</code>​，但是需要 <code>bar</code>​，而 <code>libbar.a</code>​ 已经被跳过。</li></ul><p><strong>经验法则：</strong>  如果库 A 依赖于库 B，则在链接命令中 A 应该放在 B 之前。</p><h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><p>当静态库 A 依赖于静态库 B，同时静态库 B 也依赖于静态库 A 时，会出现循环依赖。</p><p>例如，将上例中的 <code>bar.cpp</code>​ 修改为：</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;void foo();void bar() {    std::cout &lt;&lt; "bar()" &lt;&lt; std::endl;    foo();}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时，<code>libfoo.a</code>​ 和 <code>libbar.a</code>​ 相互依赖。</p><ul><li>​<code>g++ -o app.exe main.o libfoo.a libbar.a</code>​：<strong>成功</strong></li><li>​<code>g++ -o app.exe main.o libbar.a libfoo.a</code>​：<strong>失败</strong>，提示 <code>undefined reference to 'foo'</code>​</li></ul><p>在循环依赖的情况下，简单的调整静态库顺序可能无法解决问题。</p><h2 id="动态库链接-SO"><a href="#动态库链接-SO" class="headerlink" title="动态库链接 (SO)"></a>动态库链接 (SO)</h2><p>对于动态库（<code>.so</code>​ 文件在 Linux/Unix 上），链接行为有所不同。</p><ul><li><strong>SO 文件：</strong>  链接时 <code>ld</code>​ 将 <code>.so</code>​ 文件视为一个整体进行处理，类似于处理单个目标文件。多个 <code>.so</code>​ 文件之间的链接顺序通常不影响结果。</li></ul><p><strong>重要区别：</strong>  生成 SO 时允许存在未解析的符号（在运行时解析）。</p><h2 id="解决链接问题的进阶选项"><a href="#解决链接问题的进阶选项" class="headerlink" title="解决链接问题的进阶选项"></a>解决链接问题的进阶选项</h2><p>如果默认的链接行为无法解决问题，<code>ld</code>​ 提供了一些选项来控制链接过程：</p><h3 id="1-start-group​-和-end-group​"><a href="#1-start-group​-和-end-group​" class="headerlink" title="1. -start-group​ 和 -end-group​"></a>1. <code>-start-group</code>​ 和 <code>-end-group</code>​</h3><p>这两个选项可以将多个静态库视为一个组，使得 <code>ld</code>​ 在组内所有静态库中循环扫描，直到无法解析出新的未定义符号或者没有新的未定义符号。这可以解决循环依赖问题。</p><pre class="line-numbers language-none"><code class="language-none">g++ -o app.exe main.o -Wl,-start-group libfoo.a libbar.a -Wl,-end-group<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意：</strong>  使用 <code>-start-group</code>​ 和 <code>-end-group</code>​ 会增加链接时间，尤其是在大型项目中。</p><h3 id="2-whole-archive​-和-no-whole-archive​"><a href="#2-whole-archive​-和-no-whole-archive​" class="headerlink" title="2. --whole-archive​ 和 --no-whole-archive​"></a>2. <code>--whole-archive</code>​ 和 <code>--no-whole-archive</code>​</h3><p>​<code>--whole-archive</code>​ 选项会强制 <code>ld</code>​ 将其后所有静态库中的所有目标文件都链接进来，无论这些目标文件是否被需要。<code>--no-whole-archive</code>​ 选项则恢复默认的链接行为。</p><pre class="line-numbers language-none"><code class="language-none">g++ -o app.exe main.o -Wl,--whole-archive libbar.a -Wl,--no-whole-archive libfoo.a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意：</strong>  使用 <code>--whole-archive</code>​ 会显著增大最终生成文件的体积，因为会链接进大量可能不需要的代码。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文深入探讨了 GNU 链接器 <code>ld</code>​ 的工作机制，特别是关于链接顺序的细节，内容要点包括：</p><ul><li>导出符号和未定义符号的概念。</li><li>​<code>nm</code>​ 工具查看符号信息的使用方法。</li><li>目标文件之间的链接顺序不重要。</li><li>静态库之间的链接顺序很重要：<strong>被依赖的库应该放在依赖它的库的后面</strong>。</li><li>循环依赖需要特殊处理，可以使用 <code>-start-group</code>​ 和 <code>-end-group</code>​ 选项。</li><li>动态库的链接行为与静态库有所不同。</li><li>谨慎使用 <code>--whole-archive</code>​ 选项。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>clangd踩坑</title>
      <link href="//post/clangd-step-on-the-pit-z1mtuml.html"/>
      <url>//post/clangd-step-on-the-pit-z1mtuml.html</url>
      
        <content type="html"><![CDATA[<p>记一次clangd踩坑的经历，算是对clangd的整个原理有一个初步的了解把。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>使用clangd来看Linux内核的代码，发现<code>psi.c</code>​这个源文件没有办法跳转，使用Python生成的<code>compile_commands.json</code>​没有psi这个文件，让我一度认为我在编译的时候没有开启，在我认真检查了之后，我是用<code>nm</code>​查看了生成的最终的vmlinux，发现有这个源文件中的函数符号。</p><p>后来我想到，他可能被其他其他源文件包含了，所以我全局搜索了<code># include "psi.c"</code>​，发现他被包含在<code>build_utility.c</code>​。</p><p>那么当时我认为是include之后，编译时候这些符号直接就成了<code>build_utility.c</code>​了，但是我看debug信息发现还是正确的，符号的解析依旧是<code>psi.c</code>​的。</p><p>然后我忽然想到，既然<code>psi.c</code>​被include到了<code>build_utility.c</code>​，那么他的头文件是怎么处理呢。然后我就发现<strong>他自身没有头文件</strong>，这就很好解释了为什么符号能够被正确的认识，但是他自身的源代码，没有办法进行跳转，因为他没有包含任何头文件，就没有办法知道那些数据结构的结构。</p><h2 id="clangd原理"><a href="#clangd原理" class="headerlink" title="clangd原理"></a>clangd原理</h2><h3 id="编译命令"><a href="#编译命令" class="headerlink" title="编译命令"></a>编译命令</h3><p>解释源代码需要一定的上下文。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span> <span class="token comment">// 这究竟是哪个文件？</span></span><span class="token keyword">char</span> data<span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 这个数组有多大？</span>@<span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">;</span> <span class="token comment">// 是 Objective-C，还是只是语法错误？</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++ 编译器期望这些上下文通过命令行标志传递（并提供一些默认值）。一个命令可能看起来像这样：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">clang <span class="token parameter variable">-x</span> objective-c++ -I/path/headers <span class="token parameter variable">--target</span><span class="token operator">=</span>x86_64-pc-linux-gnu <span class="token parameter variable">-DNDEBUG</span> foo.mm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>他首先肯定去一些默认的地方去读取，但是一个复杂的项目他的头文件路径也是非常复杂的。</p><p>他的解决方案是为每一个源文件配置一个虚拟编译命令(例如 <code>clang foo.cc -Iheaders/</code>​)，他通过解析这个命令来确定他的依赖和配置。理想情况下，这些虚拟编译命令的有构建系统比如cmake这些来实现，他就是告诉了我们每个源文件怎么编译，去哪里找头文件，宏的值是什么。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引包含了整个代码库的信息，这些信息包括符号等大量信息。</p><p>每当我们打开一个新的源文件，他首先解析头文件中的数据，他根据虚拟编译命令，知道了从哪里找到这些头文件，然后递归的处理这些头文件。</p><p>然后clangd依赖的是clangd，他会将整个代码解析为ast，笼统的说就是使用编译原理的词法分析、语法分析以及语义分析。然后将类、函数这些符号构建成相应的索引，这样就可以了。</p><p>然后我们就能进行各种跳转了。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>‍</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客工作流</title>
      <link href="//post/blog-workflow-m2fhx.html"/>
      <url>//post/blog-workflow-m2fhx.html</url>
      
        <content type="html"><![CDATA[<h1 id="博客工作流"><a href="#博客工作流" class="headerlink" title="博客工作流"></a>博客工作流</h1><p>这篇文章主要总结了我现在的博客的工作流，主要包括怎么写博客，怎么发布博客，怎么管理博客。</p><p>很久之前写博客的话是使用vscode 来写，然后本地需要node js环境，渲染成相应的静态页面之后，推送到静态存储上。</p><p>但是这个有一些问题：</p><ol><li>迁移性的问题，你换了电脑这些，node js环境就丢了，需要重新搭建，并且在win上安装这些不是很方便</li><li>vscode写博客不是很方便，在加上图床这些，还是有一些麻烦的</li></ol><p>之后尝试过各种混搭，比如typora来写，但是总是有各种问题，后来直接博客就荒废了，直接就嗯写markdown，保存在本地，vscode上有个私有备份。但是嗯写markdown你懂的，太难用了。</p><p>之后遇到了飞书云文档，不得不说做的是真好用，各种富文本的使用起来真方便，但是他的导出比较费劲，并且分享起来也很麻烦。</p><p>随后就看到各种在线笔记各种爆雷，再加上飞书的文档导出给我气坏了，就比较关注本地笔记的存放，看到了思源这个软件，他是本地存放的，并且可以加密备份。后来发现他支持hexo的发布，所以就想着再把博客搭建起来，并且之前的node js的问题，也可以使用github的action来实现。</p><p>‍</p><p>所以我现在的工作流是</p><ol><li><p>使用思源来写本地的笔记，还是满方便的，图片可以直接上传到图床。原始的markdown也可以加密之后上传到对象存储中。</p></li><li><p>然后就是自动的发布工具。我们可以将我们的博客以markdown的方式自动上传到github的博客仓库中，具体来说可能是博客的source的_post的</p></li><li><p>push触发ci，他就启动一个容器来进行渲染，并且也可以推送到对象存储和github上。</p><ol><li>在一定程度上也可以保证安全性，就是阿里云的密钥这些</li></ol></li></ol><p>以上呢，就是一个大致的工作流。</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中断处理</title>
      <link href="//post/interrupt-treatment-z1e95yf.html"/>
      <url>//post/interrupt-treatment-z1e95yf.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://pic.zbs4017.top/interrupts-20240905175725-vjman95.png" alt="image"></p><h1 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h1><p>这篇文章是梳理中断发生的时候，CPU和内核是怎么工作的，最终处理完成这次中断。</p><h1 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h1><p>中断这个概念有一段历史了，中途有很多重叠的概念，比如异常，陷入这些，在加上国外资料的翻译问题，导致在这个概念有很多模糊的地方。我分类的时候是按照Intel手册的标准分类的，也就是<strong>同步中断</strong>和<strong>异步中断</strong>。</p><ol><li><p>同步中断：也就是中断发生CPU现在执行的代码有一定的联系。比如除零操作，缺页中断，syscall这些。当CPU执行指令遇到这些的时候，CPU内部就是产生信号去处理。</p><ol><li>产生信号和处理这些信号是通过与或门这些电路来实现的，当发生这些事件的时候，一个电路可能就直接置位了，然后通过电路就去处理这些了</li></ol></li><li><p>异步中断：这就是我们常见的键盘、网卡这些设备。他们什么时候发生中断是不确定的，所以是异步中断</p><ol><li>这个也是与或门实现的，CPU可能根据引脚来做判断，注意这个判断不是if语句这种实现的，而是与或门实现的。一旦发生，就不再执行下一条正常指令了。</li></ol></li></ol><h1 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h1><p>整个中断系统是由3部分组成的</p><ol><li><p>可编程中断控制器，也就是PIC，需要将这个东西配置好，设备来了请求之后，先到PIC，然后转发到CPU上的引脚</p></li><li><p>CPU也必须接受来自PIC的请求，并且根据中断描述符表(IDT)来找到具体的中断服务例程(简单说就是处理这次中断的函数)</p></li><li><p>操作系统必须提供相应的中断服务例程来处理这些请求。这些需要内核和驱动共同实现</p><ol><li>比如网卡的数据包，我们需要网卡驱动将数据包poll出来，然后转换成skb</li><li>对于缺页中断这种，就不需要驱动了，就是内核来全权处理了</li></ol></li></ol><p>​<img src="http://pic.zbs4017.top/image-20240905200716-hqv3jgg.png">​</p><h2 id="可编程中断控制器"><a href="#可编程中断控制器" class="headerlink" title="可编程中断控制器"></a>可编程中断控制器</h2><p>中断控制器是一种硬件，各种外围设备连接在中断控制器上而不是直接连接在cpu上。这样有一些好处：</p><ol><li>可以在中断控制器上处理设备的优先级问题</li><li>可以节约CPU的引脚，达到多路复用的作用</li></ol><p>最初的中断控制器被集成在南桥芯片中，但是由于多核处理器，中断的管理越来越复杂，所以就有了专门的高级可编程中断控制器。</p><p>对于硬件的东西这篇文章不会详细介绍，这篇文章主要是将整个中断的过程讲解清楚。</p><h2 id="中断描述符表"><a href="#中断描述符表" class="headerlink" title="中断描述符表"></a>中断描述符表</h2><p>他是一个系统表，里面的存放这具体的中断服务例程。</p><p>这个表在Linux启动的时候进行初始化，将各种处理函数的代码段内存地址放在这个地方，你可以简单的认为这是一个数组，索引是发生的中断号，里面的内容就是函数地址。</p><p>这个中断描述符表的起始地址通过<code>lidt</code>​这个命令存放在一个寄存器中</p><h2 id="中断服务例程"><a href="#中断服务例程" class="headerlink" title="中断服务例程"></a>中断服务例程</h2><p>这个就是具体的处理函数，一般来说有驱动程序和Linux内核来共同协作完成任务。</p><p>这些服务例程将在中断发生的时候被调用，但是需要注意的是，这些服务例程的调用不是我们能控制的，这里的控制指的是想普通函数调用一样使用call或者jmp命令可以调用的，它是由CPU来调用的，他会做一些幕后工作来将控制权交给你的中断服务例程。</p><h2 id="CPU执行过程"><a href="#CPU执行过程" class="headerlink" title="CPU执行过程"></a>CPU执行过程</h2><p>如果中断发生在用户空间：</p><ol><li><p>临时保存内部的一些寄存器，比如rbp、rsp、eflag、cs、ip这些寄存器，这些寄存器一般直接存放在cpu上的一些空间内</p></li><li><p>从tss(如果你不了解，可以简单的认为他保存了内核栈的地址)中找到内核栈，并把这个内核栈的栈顶和栈底加载到相应的寄存器中，这样就相当于切换到了新的栈</p></li><li><p>然后把第一步的这些信息压栈到内核栈</p></li><li><p>如果需要的话，可以把错误码这些信息也放入内核栈</p><ol><li>比如，缺页中断，你需要知道到底是什么原因发生了缺页中断，比如是因为写了只有读权限的页表项，这些信息可以辅助我们之后进行处理</li></ol></li><li><p>然后cpu在根据idt的寄存器中的信息，找到中断描述符表的起始地址，然后在找到具体的服务例程，最后在放入cs ip中，相当于栈帧线程就伪造了好了，控制权已经在内核里面了</p></li></ol><p>如果已经是内核态了，那么我们现在的栈已经是内核栈了，所以在这种情况下不需要通过tss找到内核栈，直接把放进去就可以了</p><ol><li>直接将当前EFLAGS、CS和EIP寄存器的内容压入栈</li><li>如果需要，把错误码入栈</li><li>然后cpu在根据idt的寄存器中的信息，找到中断描述符表的起始地址，然后在找到具体的服务例程，最后在放入cs ip中，相当于栈帧线程就伪造了好了，控制权已经在内核里面了</li></ol><p>他的最终的栈帧是这个样子：</p><p>​<img src="http://pic.zbs4017.top/image-20240905212417-btyhgfa.png" alt="image">​</p><h2 id="服务例程详解"><a href="#服务例程详解" class="headerlink" title="服务例程详解"></a>服务例程详解</h2><p>然后控制权到了中断服务例程里面，那么这个中断服务例程应该做那些东西呢？</p><p>首先，由于有的中断是异步发生的，我们不能对发生中断的时间有任何的假设，这就要求我们在处理中断的时候保存全部的状态，一般来说这些状态直接或间接的保存在寄存器中，CPU使用<strong>pusha</strong>指令来完成。根据不同的情况，可能还需要关闭中断这些。</p><p>然后应该就是想中断控制机发送信号表示受到了信号。最后完成工作之后，应该正确的返回，首先回复之前的状态，然后sti启动中断，然后iret就可以从中断返回。他可以正确的操作栈帧，恢复到之前的执行状态。</p><p>这是基本的ISR算法：</p><ol><li>保存被中断过程的状态</li><li>通过向PIC发送EOI来确认中断</li><li>执行工作</li><li>恢复被中断过程的状态</li><li>启用中断</li><li>用iret退出中断处理程序</li></ol><h1 id="完整过程"><a href="#完整过程" class="headerlink" title="完整过程"></a>完整过程</h1><p>现在为了完整地展示，让我们看看键盘按下是如何处理的：</p><p>设置中断：</p><ol><li>创建IDT表</li><li>设置IDT条目9，使用指向键盘ISR的中断门</li><li>用lidt加载IDT地址</li><li>向PIC1发送中断掩码0xfd（11111101）以取消掩码（启用）IRQ1</li><li>用sti启用中断</li></ol><p>人按下键盘按钮：</p><ol><li>键盘控制器在PIC1中提升中断线IRQ1</li><li>PIC检查这条线是否未被屏蔽（它没有），并向CPU发送中断号9</li><li>CPU通过检查EFLAGS中的IF来检查中断是否被禁用（它没有）</li><li>（假设我们当前在内核模式下执行）</li><li>将EFLAGS、CS和EIP压入栈</li><li>将来自PIC的错误代码（如果适用）压入栈</li><li>查看由idtr指向的IDT，并从IDT描述符9中获取段选择器</li><li>检查特权级别，并将段选择器和ISR地址加载到CS:EIP</li><li>清除IF标志，因为IDT条目是中断门</li><li>将控制权传递给ISR</li></ol><p>在ISR中接收中断：</p><ol><li>用cli禁用中断（以防万一）</li><li>用pusha保存被中断过程的状态</li><li>通过向主PIC发送EOI（0x20）来确认中断（I/O端口0x20）</li><li>从键盘控制器读取键盘状态（I/O端口0x64）</li><li>如果状态为1，则从键盘控制器读取键码（I/O端口0x60）</li><li>最后，通过VGA缓冲区打印字符或将其发送到TTY</li></ol><p>从中断返回：</p><ol><li>用popa恢复被中断过程的状态</li><li>用sti启用中断</li><li>iret</li></ol><p>‍</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 中断 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sizeof 大小计算</title>
      <link href="//post/sizeof-size-calculation-2mvg8s.html"/>
      <url>//post/sizeof-size-calculation-2mvg8s.html</url>
      
        <content type="html"><![CDATA[<h1 id="sizeof-大小计算"><a href="#sizeof-大小计算" class="headerlink" title="sizeof 大小计算"></a>sizeof 大小计算</h1><p>首先，sizeof是一种单目运算符，他并不是函数，在编译器就可以得到类的大小是多少。</p><p>‍</p><p>这个里面主要的问题就是类的大小的计算过程：</p><ol><li><p>首先，对于空类来说 ，sizeof 是1。因为每个类都需要在内存中有一个唯一的标识，所以他必须需要占用一定的大小。并且cpp标准里面规定了，sizeof的结果必须是非0值。</p></li><li><p>其次就是重叠对象的问题。如果这个空对象作为一个类的成员，那么他就是char一样，需要占用一定的内存</p><ol><li><pre><code class="c++"> #include &lt;iostream&gt; struct Empty {}; struct ContainsEmpty {     Empty e;     int i; }; int main() {     std::cout &lt;&lt; "sizeof(Empty): " &lt;&lt; sizeof(Empty) &lt;&lt; std::endl;     std::cout &lt;&lt; "sizeof(int): " &lt;&lt; sizeof(int) &lt;&lt; std::endl;     std::cout &lt;&lt; "sizeof(ContainsEmpty): " &lt;&lt; sizeof(ContainsEmpty) &lt;&lt; std::endl;     return 0; } <pre class="line-numbers language-none"><code class="language-none">2. ```cpp    sizeof(Empty): 1    sizeof(int): 4    sizeof(ContainsEmpty): 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></code></pre></li></ol></li><li><p>如果是空类被继承的话，这个时候计算的就会忽略父类的大小</p><ol><li><pre><code class="cpp"> #include &lt;iostream&gt; struct Empty {}; struct ContainsEmpty:public Empty {     int i;     // Empty e; }; int main() {     std::cout &lt;&lt; "sizeof(Empty): " &lt;&lt; sizeof(Empty) &lt;&lt; std::endl;     std::cout &lt;&lt; "sizeof(int): " &lt;&lt; sizeof(int) &lt;&lt; std::endl;     std::cout &lt;&lt; "sizeof(ContainsEmpty): " &lt;&lt; sizeof(ContainsEmpty) &lt;&lt; std::endl;     return 0; } <pre class="line-numbers language-none"><code class="language-none">```cppsizeof(Empty): 1sizeof(int): 4sizeof(ContainsEmpty): 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre></li></ol></li><li><p>然后就是普通类的计算法则</p><ol><li><p>类的大小必须要是类中成员最大值的整数倍。这个主要考虑的点是数组的情况，比如在数组情况下，我们申请了多个相邻的对象，如果没有添加补充，不是成员最大值的整数倍，那么在数组情况下最终还是会发生偏移。</p><ol><li><a href="https://blog.csdn.net/zyz770834013/article/details/71909055">这片文章</a>里面详细说明了</li></ol></li><li><p>每个成员的起始地址都要是自己的整数倍才可以。这个比较容易理解，主要是内存对其的好处，不会跨cache line访问。</p></li><li><p>有了这两个规则，普通的，平凡类型的类我们就可以计算了。</p></li></ol></li><li><p>接下来就是包含虚函数的问题了</p><ol><li>虚函数的实现，需要虚函数指针。64位下占用8字节。每个基类都要占用一个。</li><li>他是一层一层叠的，按照书写的顺序，第一个类的虚函数指针，然后第一个类的成员。注意对齐。然后是第二各类的虚函数指针，然后是第二各类的数据成员</li><li>这个时候也就需要遵守普通的类的规范，也就是说要各种对齐</li></ol></li><li><p>最后也就是虚基类的事情了</p><ol><li><p>虚基类是解决菱形继承的问题</p></li><li><p>他的数据成员的布局是这样的，首先是普通基类的数据布局，普通基类的数据成员按照上面说的逐个排列。</p></li><li><p>在最后的地方，存放虚基类。然后问题就是我们怎么找到虚基类。无论是我们的子类，还是说上层的基类，都需要相应的索引找到对应的虚基类。</p></li><li><p>在数据成员开始的地方，我们需要一个虚基址表，用于这个类去找到虚基类的数据。这个虚表就是，他的作用就是方便对象去寻找自己的虚基类成员。</p></li><li><p>这里还会有一些拓展，就是说如果伴随着虚基类，这个可能会更加复杂。</p><ol><li>如果主基类里面也有虚函数，那么第一个虚指针会服用。</li><li>随后就是按照场里，每个基类都有一个虚指针</li><li>如果虚基类里面也有虚函数，那么在虚基类上面也会有虚指针。</li></ol></li></ol></li></ol><p>‍</p>]]></content>
      
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>返回值优化汇编分析</title>
      <link href="//post/back-value-optimization-z8yxga.html"/>
      <url>//post/back-value-optimization-z8yxga.html</url>
      
        <content type="html"><![CDATA[<p>返回值优化是一个很经典的问题，很多面试官也会针对返回值优化和拷贝复制和移动复制问一些问题。</p><p>当一个<strong>未命名且未绑定到任何引用的临时变量</strong>被移动或复制到一个相同的对象时，拷贝和移动构造可以被省略。当这个临时对象在被构造的时候，他会直接被构造在将要拷贝/移动到的对象。当未命名临时对象是函数返回值时，发生的省略拷贝的行为被称为RVO，”返回值优化”。</p><p>他的作用是可以优化栈上的临时对象，并且也可以减少复制的开销。</p><h2 id="禁止返回值优化"><a href="#禁止返回值优化" class="headerlink" title="禁止返回值优化"></a>禁止返回值优化</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>如果我们禁止了返回值优化，那么从函数中返回对象，一种实现办法是在函数调用语句前在stack frame上声明一个隐藏对象，把该对象的地址隐蔽传入被调用函数，函数的返回对象直接构造或者复制构造到该地址上。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct BigObject {};BigObject foo() {  BigObject ret;  // generate ret  return ret;}int main() {  BigObject o = foo();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可能产生的代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct BigObject {};BigObject * foo(BigObject * _hiddenAddress) {  BigObject ret = {};  // copy result into hidden object  *_hiddenAddress = ret;  return _hiddenAddress;}int main() {  BigObject _hidden; // create hidden object  BigObject o = *foo(&amp;_hidden); // copy the result into d}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这引起了BigObject对象被复制两次，也就是上图中左侧图片描述的过程。</p><p>优化之后可能会产生如下的代码：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct BigObject {};void f(BigObject&amp; ret_value) {  BigObject localObj;  return ret_value.BigObject::BigObject(std::move(localObj));//显式构造}int main() {  BigObject o; ///这里没有使用默认构造，定义而不构造  f(&amp;o);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回的类对象直接被构造在将要拷贝/移动到的对象栈空间上,只会产生一次构造/析构，优化掉了栈上的临时对象。</p><p>‍</p><p>下面我就使用这个代码来分别看下这个代码在11和17下的汇编，来分析具体的实现。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;bits/stdc++.h&gt;using namespace std;static int counter; // counter to identify instancesstruct Data {    int i{ 0 };    int id;    Data() : id{ ++counter } {        std::cout &lt;&lt; "ctor " &lt;&lt; id &lt;&lt; "\n";    }    Data(const Data&amp; s) : i{ s.i }, id{ ++counter } {        std::cout &lt;&lt; "copy ctor " &lt;&lt; id &lt;&lt; "\n";    }    Data&amp; operator=(const Data&amp; data) {        i = data.i;        std::cout &lt;&lt; "copy assign " &lt;&lt; data.id &lt;&lt; " to " &lt;&lt; id &lt;&lt; "\n";        return *this;    }    ~Data() {        std::cout &lt;&lt; "dtor " &lt;&lt; id &lt;&lt; "\n";    }};Data GetData() {    return Data{};}int main() {    Data d = GetData();      return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="C-11-14"><a href="#C-11-14" class="headerlink" title="C++11-14"></a>C++11-14</h3><p>在C++11到14的标准中，并没有明确的规定返回值优化必须要做，但是大部分的编译器都是执行这个优化。</p><p>使用<code>-fno-elide-constructors</code>​这个标志就可以了。</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">.LC0:        .string "ctor ".LC1:        .string "\n"Data::Data() [base object constructor]:        push    rbp        mov     rbp, rsp        push    rbx        sub     rsp, 24        mov     QWORD PTR [rbp-24], rdi        mov     rax, QWORD PTR [rbp-24]        mov     DWORD PTR [rax], 0        mov     eax, DWORD PTR counter[rip]        add     eax, 1        mov     DWORD PTR counter[rip], eax        mov     edx, DWORD PTR counter[rip]        mov     rax, QWORD PTR [rbp-24]        mov     DWORD PTR [rax+4], edx        mov     rax, QWORD PTR [rbp-24]        mov     ebx, DWORD PTR [rax+4]        mov     esi, OFFSET FLAT:.LC0        mov     edi, OFFSET FLAT:std::cout        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)        mov     esi, ebx        mov     rdi, rax        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int)        mov     esi, OFFSET FLAT:.LC1        mov     rdi, rax        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)        nop        add     rsp, 24        pop     rbx        pop     rbp        ret.LC2:        .string "copy ctor "Data::Data(Data const&amp;) [base object constructor]:        push    rbp        mov     rbp, rsp        push    rbx        sub     rsp, 24        mov     QWORD PTR [rbp-24], rdi        mov     QWORD PTR [rbp-32], rsi        mov     rax, QWORD PTR [rbp-32]        mov     edx, DWORD PTR [rax]        mov     rax, QWORD PTR [rbp-24]        mov     DWORD PTR [rax], edx        mov     eax, DWORD PTR counter[rip]        add     eax, 1        mov     DWORD PTR counter[rip], eax        mov     edx, DWORD PTR counter[rip]        mov     rax, QWORD PTR [rbp-24]        mov     DWORD PTR [rax+4], edx        mov     rax, QWORD PTR [rbp-24]        mov     ebx, DWORD PTR [rax+4]        mov     esi, OFFSET FLAT:.LC2        mov     edi, OFFSET FLAT:std::cout        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)        mov     esi, ebx        mov     rdi, rax        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int)        mov     esi, OFFSET FLAT:.LC1        mov     rdi, rax        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)        nop        add     rsp, 24        pop     rbx        pop     rbp        ret.LC3:        .string "dtor "Data::~Data() [base object destructor]:        push    rbp        mov     rbp, rsp        push    rbx        sub     rsp, 24        mov     QWORD PTR [rbp-24], rdi        mov     rax, QWORD PTR [rbp-24]        mov     ebx, DWORD PTR [rax+4]        mov     esi, OFFSET FLAT:.LC3        mov     edi, OFFSET FLAT:std::cout        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)        mov     esi, ebx        mov     rdi, rax        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int)        mov     esi, OFFSET FLAT:.LC1        mov     rdi, rax        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)        nop        add     rsp, 24        pop     rbx        pop     rbp        retGetData():        push    rbp        mov     rbp, rsp        push    rbx        sub     rsp, 40        mov     QWORD PTR [rbp-40], rdi        lea     rax, [rbp-24]        mov     rdi, rax        call    Data::Data() [complete object constructor]        lea     rdx, [rbp-24]        mov     rax, QWORD PTR [rbp-40]        mov     rsi, rdx        mov     rdi, rax        call    Data::Data(Data const&amp;) [complete object constructor]        lea     rax, [rbp-24]        mov     rdi, rax        call    Data::~Data() [complete object destructor]        jmp     .L8        mov     rbx, rax        lea     rax, [rbp-24]        mov     rdi, rax        call    Data::~Data() [complete object destructor]        mov     rax, rbx        mov     rdi, rax        call    _Unwind_Resume.L8:        mov     rax, QWORD PTR [rbp-40]        add     rsp, 40        pop     rbx        pop     rbp        retmain:        push    rbp        mov     rbp, rsp        push    rbx        sub     rsp, 24        lea     rax, [rbp-24]        mov     rdi, rax        call    GetData()        lea     rdx, [rbp-24]        lea     rax, [rbp-32]        mov     rsi, rdx        mov     rdi, rax        call    Data::Data(Data const&amp;) [complete object constructor]        lea     rax, [rbp-24]        mov     rdi, rax        call    Data::~Data() [complete object destructor]        mov     ebx, 0        lea     rax, [rbp-32]        mov     rdi, rax        call    Data::~Data() [complete object destructor]        mov     eax, ebx        jmp     .L13        mov     rbx, rax        lea     rax, [rbp-24]        mov     rdi, rax        call    Data::~Data() [complete object destructor]        mov     rax, rbx        mov     rdi, rax        call    _Unwind_Resume.L13:        add     rsp, 24        pop     rbx        pop     rbp        ret__static_initialization_and_destruction_0(int, int):        push    rbp        mov     rbp, rsp        sub     rsp, 16        mov     DWORD PTR [rbp-4], edi        mov     DWORD PTR [rbp-8], esi        cmp     DWORD PTR [rbp-4], 1        jne     .L16        cmp     DWORD PTR [rbp-8], 65535        jne     .L16        mov     edi, OFFSET FLAT:std::__ioinit        call    std::ios_base::Init::Init() [complete object constructor]        mov     edx, OFFSET FLAT:__dso_handle        mov     esi, OFFSET FLAT:std::__ioinit        mov     edi, OFFSET FLAT:std::ios_base::Init::~Init() [complete object destructor]        call    __cxa_atexit.L16:        nop        leave        ret_GLOBAL__sub_I_GetData():        push    rbp        mov     rbp, rsp        mov     esi, 65535        mov     edi, 1        call    __static_initialization_and_destruction_0(int, int)        pop     rbp        ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">ctor 1copy ctor 2dtor 1copy ctor 3dtor 2dtor 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们来分析一下，main函数在他的栈帧上分配了一块地址，把他赋值给rdi，虽然<code>GetData</code>​没有参数，但是还是要传递进去。</p><p>然后在函数的栈帧中我们在申请一块内存，用于构建新的对象。然后</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">lea     rdx, [rbp-24];这个是GetData栈帧上创建的对象，地址mov     rax, QWORD PTR [rbp-40];这个是main栈帧上的那么mov     rsi, rdx;第二个参数，拷贝构造函数mov     rdi, rax;第一个参数，thiscall    Data::Data(Data const&amp;) [complete object constructor];这个就非常明确了，传递进去，进行拷贝赋值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就是调用这个析构函数。然后ret返回main的栈帧。</p><p>main的栈帧我们再次进行拷贝初始化，最后就是析构了。</p><h3 id="C-17"><a href="#C-17" class="headerlink" title="C++17"></a>C++17</h3><p>现在我们使用C++17，在C++17中，确定了标准，也就是返回值必须要优化，即使使用参数也没有用。</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">.LC0:        .string "ctor ".LC1:        .string "\n"Data::Data() [base object constructor]:        push    rbp        mov     rbp, rsp        sub     rsp, 16        mov     QWORD PTR [rbp-8], rdi        mov     rax, QWORD PTR [rbp-8]        mov     DWORD PTR [rax], 0        mov     eax, DWORD PTR counter[rip]        add     eax, 1        mov     DWORD PTR counter[rip], eax        mov     edx, DWORD PTR counter[rip]        mov     rax, QWORD PTR [rbp-8]        mov     DWORD PTR [rax+4], edx        mov     esi, OFFSET FLAT:.LC0        mov     edi, OFFSET FLAT:std::cout        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)        mov     rdx, rax        mov     rax, QWORD PTR [rbp-8]        mov     eax, DWORD PTR [rax+4]        mov     esi, eax        mov     rdi, rdx        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int)        mov     esi, OFFSET FLAT:.LC1        mov     rdi, rax        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)        nop        leave        ret.LC2:        .string "copy ctor "Data::Data(Data const&amp;) [base object constructor]:        push    rbp        mov     rbp, rsp        sub     rsp, 16        mov     QWORD PTR [rbp-8], rdi        mov     QWORD PTR [rbp-16], rsi        mov     rax, QWORD PTR [rbp-16]        mov     edx, DWORD PTR [rax]        mov     rax, QWORD PTR [rbp-8]        mov     DWORD PTR [rax], edx        mov     eax, DWORD PTR counter[rip]        add     eax, 1        mov     DWORD PTR counter[rip], eax        mov     edx, DWORD PTR counter[rip]        mov     rax, QWORD PTR [rbp-8]        mov     DWORD PTR [rax+4], edx        mov     esi, OFFSET FLAT:.LC2        mov     edi, OFFSET FLAT:std::cout        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)        mov     rdx, rax        mov     rax, QWORD PTR [rbp-8]        mov     eax, DWORD PTR [rax+4]        mov     esi, eax        mov     rdi, rdx        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int)        mov     esi, OFFSET FLAT:.LC1        mov     rdi, rax        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)        nop        leave        ret.LC3:        .string "dtor "Data::~Data() [base object destructor]:        push    rbp        mov     rbp, rsp        sub     rsp, 16        mov     QWORD PTR [rbp-8], rdi        mov     esi, OFFSET FLAT:.LC3        mov     edi, OFFSET FLAT:std::cout        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)        mov     rdx, rax        mov     rax, QWORD PTR [rbp-8]        mov     eax, DWORD PTR [rax+4]        mov     esi, eax        mov     rdi, rdx        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int)        mov     esi, OFFSET FLAT:.LC1        mov     rdi, rax        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)        nop        leave        retGetData():        push    rbp        mov     rbp, rsp        push    rbx        sub     rsp, 40        mov     QWORD PTR [rbp-40], rdi        lea     rax, [rbp-24]        mov     rdi, rax        call    Data::Data() [complete object constructor]        lea     rdx, [rbp-24]        mov     rax, QWORD PTR [rbp-40]        mov     rsi, rdx        mov     rdi, rax        call    Data::Data(Data const&amp;) [complete object constructor]        nop        lea     rax, [rbp-24]        mov     rdi, rax        call    Data::~Data() [complete object destructor]        jmp     .L8        mov     rbx, rax        lea     rax, [rbp-24]        mov     rdi, rax        call    Data::~Data() [complete object destructor]        mov     rax, rbx        mov     rdi, rax        call    _Unwind_Resume.L8:        mov     rax, QWORD PTR [rbp-40]        mov     rbx, QWORD PTR [rbp-8]        leave        retmain:        push    rbp        mov     rbp, rsp        push    rbx        sub     rsp, 24        lea     rax, [rbp-24]        mov     rdi, rax        call    GetData()        lea     rdx, [rbp-24]        lea     rax, [rbp-32]        mov     rsi, rdx        mov     rdi, rax        call    Data::Data(Data const&amp;) [complete object constructor]        lea     rax, [rbp-24]        mov     rdi, rax        call    Data::~Data() [complete object destructor]        mov     ebx, 0        lea     rax, [rbp-32]        mov     rdi, rax        call    Data::~Data() [complete object destructor]        mov     eax, ebx        jmp     .L13        mov     rbx, rax        lea     rax, [rbp-24]        mov     rdi, rax        call    Data::~Data() [complete object destructor]        mov     rax, rbx        mov     rdi, rax        call    _Unwind_Resume.L13:        mov     rbx, QWORD PTR [rbp-8]        leave        ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">ctor 1dtor 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以很清楚的看到，只进行了一次初始化。</p><h2 id="其余特殊的优化"><a href="#其余特殊的优化" class="headerlink" title="其余特殊的优化"></a>其余特殊的优化</h2><h3 id="所有分支返回同一个具名对象"><a href="#所有分支返回同一个具名对象" class="headerlink" title="所有分支返回同一个具名对象"></a>所有分支返回同一个具名对象</h3><p>若分支返回全是同一具名对象, 发生返回值优化. <a href="https://link.juejin.cn/?target=https://godbolt.org/z/TE4qfxzfG" title="https://godbolt.org/z/TE4qfxzfG">运行代码</a></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cstddef&gt;#include &lt;cstring&gt;#include &lt;utility&gt;static int counter; // counter to identify instances of Sstruct Data {    int i{ 0 };    int id;    Data() : id{ ++counter } {        std::cout &lt;&lt; "ctor " &lt;&lt; id &lt;&lt; "\n";    }    Data(const Data&amp; s) : i{ s.i }, id{ ++counter } {        std::cout &lt;&lt; "copy ctor " &lt;&lt; id &lt;&lt; "\n";    }    Data&amp; operator=(const Data&amp; data) {        i = data.i;        std::cout &lt;&lt; "copy assign " &lt;&lt; data.id &lt;&lt; " to " &lt;&lt; id &lt;&lt; "\n";        return *this;    }    ~Data() {        std::cout &lt;&lt; "dtor " &lt;&lt; id &lt;&lt; "\n";    }};Data GetData(int param) {    Data d;      if (param % 2 == 0) {        d.i = 1;        return d;    }    else if (param % 2 == 1) {        d.i = 2;        return d;    }    return d;}int main() {    Data d = GetData(0);      return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个返回值全部都是d，所以可以使用优化，所以可以进行优化。</p><h3 id="所有分支返回非同一对象"><a href="#所有分支返回非同一对象" class="headerlink" title="所有分支返回非同一对象"></a>所有分支返回非同一对象</h3><p>若分支返回不全是同一具名对象, 则无返回值优化. 因为返回的对象在运行时确定, 编译器无法在编译期决定.</p><p><a href="https://link.juejin.cn/?target=https://godbolt.org/z/T4dce57ej" title="https://godbolt.org/z/T4dce57ej">运行代码</a></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Data GetData(int param) {    Data d;                     // ctor 1      if (param % 2 == 0) {        d.i = 1;        return d;    }    else if (param % 2 == 1) {        Data d2;        d2.i = 2;        return d2;    }    return d;}                               // copy ctor 2, dtor 1int main() {    Data d = GetData(0);      return 0;}                               // dtor 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数返回结果用于赋值"><a href="#函数返回结果用于赋值" class="headerlink" title="函数返回结果用于赋值"></a>函数返回结果用于赋值</h3><p>如果调用函数时, 造成的是拷贝赋值, 而不是拷贝构造, 即使是不具名的情况, 也不会发生返回值优化 (注: 换个思路理解, 编译器不清楚赋值左侧的值从创建到赋值之间, 将处于何种状态, 或者进行何种操作, 所以不会对这种形式做返回值优化. 为避免这种情况的拷贝赋值, 可以通过移动赋值来消除).</p><p><a href="https://link.juejin.cn/?target=https://godbolt.org/z/1cM3o547o" title="https://godbolt.org/z/1cM3o547o">运行代码</a></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Data GetData(int param) {    //!!! sub case 1    // Data d{};            // ctor 2    // return d;    //!!! sub case 2    // return Data{};       // ctor 2    //!!! sub case 3    Data d{};               // ctor 2    if (param % 2 == 0) {        d.i = 1;        return d;    } else {        d.i = 2;        return d;    }}int main() {    Data d;                 // ctor 1    d = GetData(0);         // copy assign 2 to 1    return 0;}                           // dtor 2, dtor1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个也可以理解，毕竟之前都是拷贝构造函数，因为这个对象还没有初始化，我们可以把栈上的地址传递进去。</p><p>但是如果说这个对象已经初始化了，我们怎么进行初始化，所以就没有办法来原来的地址上进行初始化了，就只能重新申请地址，把东西放到这里，然后再进行拷贝。</p><h3 id="返回一个对象的成员"><a href="#返回一个对象的成员" class="headerlink" title="返回一个对象的成员"></a>返回一个对象的成员</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">struct DataWrap {    Data d;};Data GetData() {    return DataWrap{}.d;        // ctor 1}                               // copy ctor 2, dtor 1int main() {    Data d = GetData();      return 0;}                               // dtor 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种情况下，他其实需要生成一个匿名变量，所以这个变量必须生成，所以也就无法初始化。</p><h3 id="返回值是全局的变量或是其他变量"><a href="#返回值是全局的变量或是其他变量" class="headerlink" title="返回值是全局的变量或是其他变量"></a>返回值是全局的变量或是其他变量</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Data sd{};                  // ctor 1Data GetData() {    return sd;              }                           // copy ctor 2, dtor 1int main() {    Data d = GetData();      return 0;}             <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于这种嘛，也可以理解，毕竟这个对象已经生成了，只能进行拷贝赋值了。</p><p>‍</p><p>其实上面的这些例子，当我们了解了他的原理就可以很容器的想到。我们之所以能够进行返回值优化，就是因为我们在上一个栈帧中找了一块内存，作为参数传递过去。这样才可以返回值优化，如果不能根据这样，就不能进行优化，必须需要拷贝。</p><p>‍</p><p>还有就是cpp标准规定，return 一个表达式，如果这个表达式是一个自动生命周期变量(栈上变量)，并且不是volite，那么他就是可移动的，优先使用移动构造函数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
